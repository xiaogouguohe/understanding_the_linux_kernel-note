# 第2章 内存寻址

- 本章介绍寻址技术
- 关于内存管理的三章
  - 本章
  - 第8章，讨论内核怎样给自己分配内存
  - 第9张，怎样给进程分配线性地址

## 2.1 内存地址

### 2.1.1 三种不同的地址

- 逻辑地址
  - 每个逻辑地址由一个段和偏移量组成
- 线性地址（虚拟地址）
- 物理地址

### 2.1.2 逻辑地址转换

- MMU通过一种称为分段单元的硬件电路，把一个逻辑地址转换成线性地址；接着，分页单元把线性地址转换成一个物理地址，如图2-1

### 2.1.3 内存仲裁器

- 在多处理器系统中，所有CPU共享同一内存

  - 这意味着RAM芯片可以由独立的CPU并发访问

  - 但是RAM芯片上的读写必须串行执行

- 内存仲裁器插在总线和每个RAM芯片上

  - 如果某个RAM芯片空闲，就准许一个CPU访问；如果该芯片正在为另一个处理器提出的请求服务，就延迟这个CPU的访问

- 内存仲裁器在单处理器和多处理器的使用

  - 单处理器上也使用内存仲裁器，因为DMA控制器和CPU并发操作（第13章“直接内存访问（DMA）”）
  - 多处理器系统的仲裁器有多个输入端口，结构更加复杂

- 从编程观点看，仲裁器由硬件电路管理，因此是隐藏的

## 2.2 硬件中的分段

- Intel微处理器以两种不同的方式执行地址转换，这两种方式分别被称为实模式和保护模式
  - 从下一节开始描述保护模式下的地址转换
  - 实模式存在的原因是要维持处理器和早期模型兼容，并让操作系统自举？？？

### 2.2.1 段选择符和段寄存器

- 逻辑地址由两部分组成

  - 段标识符（段选择符）
    - 16位
    - 结构如图2-2
  - 指定段内相对地址的偏移量
    - 32位
- 段寄存器

  - 唯一的目的就是存放段选择符

  - 尽管只有6个，但程序可以把同一个段寄存器用于不同目的，方法是先将其值保存在内存中，用完后再恢复
  - 6个寄存器中，3个有专门的用途
    - cs：代码段寄存器，指向包含程序指令的段
      - 还有一个两位字段，来指明CPU的当前特权级
      - Linux只用0级和3级，分别表示内核态和用户态
    - ss：栈段寄存器，指向包含当前程序栈的段
    - ds：数据段寄存器，指向包含静态数据或全局数据段
    - 其它3个段寄存器做一般用途，可以指向任何数据段
- 逻辑地址如何转换成线性地址见2.2.4
- 为什么需要段机制——实模式和16位处理器
  - 8086是16位的处理器，寻址空间为1M，但是ALU只有16位，没法处理20位的地址
  - 为了解决这个问题，设置了一些段寄存器，它们也是16位的
  - 在将地址送入地址总线前，CPU先把它和某个段寄存器的值相加
    - 内存总线的高12位与段寄存器的16位相加，后4位不变，形成20位的实际地址
- 保护模式和32位处理器
  - 80386是32位处理器，可以不通过分段机制，直接访问4G的内存空间
  - 为了兼容前代处理器，必须支持实模式和保护模式

### 2.2.2 段描述符

- 每个段由一个8字节的段描述符表示，描述了段的特征
- 段描述符放在全局描述符表（GDT）或局部描述符表（LDT）
  - 通常只定义一个GDT
  - 每个进程除了存放在GDT中的段之外，如果还需要创建附加的段，就可以有自己的LDT
  - GDT在主存中的地址和大小存放在gdtr控制寄存器中
    - gdtr由48位组成，低16位表示GDT的长度，高32位表示GDT在内存中的起始地址
  - 当前正被使用的LDT地址和大小放在ldtr控制寄存器中
- 图2-3展示了段描述符的格式，表2-1解释了图2-3中各个字段的含义
  - ###
- 几种不同类型的段，以及和它们对应的段描述符
  - 代码段描述符
  - 数据段描述符
  - 任务状态段描述符（TSSD）
  - 局部描述符表描述符

### 2.2.3 快速访问段描述符

- 回忆之前的内容
  - 逻辑地址由16位段选择符和32位偏移量组成
  - 段寄存器仅仅存放段选择符

- 为了加速逻辑地址到线性地址的转换，80x86处理器提供一种附加的非编程的寄存器（不能被程序员设置），供6个可编程的段寄存器使用
  - 每个非编程的寄存器含有8个字节的段描述符，由相应的段寄存器中的段选择符指定
- 每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非编程CPU寄存器
  - 目的是，针对那个段的逻辑地址转换就可以不访问主存中的GDT或LDT，只需要直接引用存放段描述符的CPU寄存器
- 表2-2描述了段选择符包含的3个字段

### 2.2.4 分段单元

- 图2-5显示了一个逻辑地址是怎样转换成相应的线性地址的，分段单元执行如下操作
  - 先检查段选择符的TI字段，以决定段描述符保存在GDT还是激活的LDT
    - 对于这两种情况，分段单元从gdtr寄存器或ldtr寄存器中得到GDT或LDT的线性基地址
  - 把段选择符的index字段乘以8（一个段描述符的大小），这个结果与上一步获得的线性基地址相加，得到段描述符的地址
  - 把逻辑地址的偏移量和段描述符的Base字段的值相加，得到线性地址
- 因为有了与段寄存器相关的不可编程寄存器，只有当段寄存器内容被改变时才需要执行前两个操作

### 2.2.5 一些概念

- CPL, DPL和RPL
  - CPL是代码寄存器cs中的后两位，是当前执行的程序的特权级
  - DPL是段描述符的后两位，是段的特权级
  - RPL是段选择符的后两位，是请求的特权级
  - 当前程序有自己的特权级CPL，但是它可能认为要访问的段没必要这么高的特权级（安全性），因此对某个段的请求会有请求特权级（RPL），而要成功访问一个段，需要满足CPL < DPL，且RPL < DPL

- 内核段和代码段
  - 这两个说法不一定指不一样的段，例如一个进程的内核数据段和代码数据段可能是同一个段，在同一个地址，只是段描述符的DPL不同，
  - 访问者可能通过不同的分段地址，得到不同的段选择符，访问到不同的段描述符，但这两个不同的段描述符，可能描述了同一个段，只不过描述它们的特权级不同，导致了访问者对这个段的权限不同

## 2.3 Linux中的分段

- 80x86微处理器实现段机制，但Linux更倾向于使用分页方式，因为
  - 分段和分页都可以划分进程的物理地址空间
  - 当所有进程使用相同的段寄存器值时，它们能共用同样一组线性地址
  - RISC体系结构对分段的支持很有限，段机制不方便移植
- 为了绕过80x86的段机制，Linux把所有段描述符的Base都设为零
  - 这样就实现了最大限度绕过段机制，逻辑地址相当于虚拟地址的偏移量
  - 这也就解释了，为什么caspp上把虚拟地址空间划分为不同的段（区域），因为段机制被绕过了，段的逻辑地址相当于段的虚拟地址的偏移量
  - C语言程序中的32位地址，其实是逻辑地址的段内偏移量
- 表2-3列出了四个主要的Linux段的段描述符的值
  - 运行在用户态的所有Linux进程都使用用户代码段和用户数据段来对指令和数据寻址；运行在内核态的所有Linux进程都使用内核代码段和内核数据段来对指令和数据寻址
  - 相应的段选择符由宏\_\_USER\_CS,  \_\_USER\_DS,  \_\_KERNEL\_CS,  \_\_KERNEL\_DS 分别定义 
- CPU的当前特权级（CPL）反映了进程是在用户态还是内核态，并有存放在cs寄存器中的段选择符的RPL字段指定，只要当前特权级被改变，一些段寄存器必须相应地更新
  - 当CPL=3时（用户态），ds寄存器必须含有用户数据段的段选择符，ss寄存器必须含有用户数据段的段选择符；当CPL=0时，上述寄存器必须含有内核态的这些段选择符
- ###
- 除了上述的4个段以外，Linux还使用了其它几个专门的段，见2.3.1

### 2.3.1 Linux GDT

- 在单处理器系统中只有一个GDT，而多处理器系统中每个CPU对应一个GDT
- 所有的GDT都存放在cpu_gdt_table数组中，而所有的GDT的地址和大小被存放在cpu_gdt_descr数组中，当初始化gdtr寄存器时使用（2.2.2）
  - 这些符号都定义在文件arch/i386/kernel/head.S
  - 都是汇编格式，cpu_gdt_table和cpu_gdt_descr的结构究竟是怎样的？？？
- 图2-6是GDT的布局示意图
  - 每个GDT包含18个段描述符和14个保留项
    - 保留项的目的是为了是经常一起访问的描述符能够处于同一个32字节的硬件告诉缓存行中（见后面的“硬件高速缓存”一节）
  - 18个段描述符指向下列的段
    - 用户态和内核态下的代码和数据段共4个
    - 任务状态段（TSS）
      - 每个处理器有一个
      - 每个TSS相应的线性地址空间都是内核数据段相应线性地址空间的一个小子集
      - 所有的任务状态段都顺序存放在init_tss数组中
        - 怎么做到所有处理器都能访问到这个数组？？？多处理器的共享数据放在哪里？？？ 
      - 第n个CPU的TSS描述符的Base字段指向init_tss数组的第n个元素，也就是第n个任务状态段
      - ###
      - 更多细节见第3章“任务状态段”
    - 1个包括缺省局部描述符表的段
      - 被所有进程共享的段（见下一节）
    - 3个局部线程存储（TLS）段
      - ###
    - 与高级电源管理（AMP）相关的3个段
    - 与支持即插即用（PnP）功能的BIOS服务程序相关的5个段
    - 被内核用来处理“双重错误”异常的特殊TSS段（见第4章“异常”）
      - 双重错误指，处理一个异常时引发的另一个异常
- 每个处理器都有一个GDT副本，出少数情况外，所有GDT副本有相同的表项，这些少数的情况包括
  - 每个处理器有自己的TSS段，因此其对应的GDT项不同
  - 有少数GDT项可能依赖于CPU正在执行的进程（LDT和TLS段描述符）
  - 处理器可能临时修改GDT副本里的某个项，例如调用APM的BIOS例程

### 2.3.2 Linux LDT

- ###

## 2.4 硬件中的分页

- 分页单元把线性地址转换成物理地址
  - 其中一个关键任务是，把访问类型与线性地址的访问权限进行比较，如果访问无效，就产生缺页异常（第4章和第8章）
- 分页和页表
- 80386以后的80x86处理器都支持分页，通过设置cr0寄存器的PG标志启用，当PG=0时，线性地址被解释为物理地址

### 2.4.1 常规分页

- 页大小4KB
- 32位的线性地址被分成3个域
  - 高10位
  - 中间10位
  - 低12位
- 页表项的结构
  - 高20位
  - Present标志
    - 标志该页是否在主存中
    - 如果不在，触发缺页异常
  - Accessed标志
    - 每当分页单元对相应页框寻址时，设置这个标志
    - 当该页被交换出去时，操作系统根据这一标志进行一些操作
  - Dirty标志
    - 每当对一个页框进行写操作时，设置这个标志
    - 当该页被交换出去时，操作系统根据这一标志进行一些操作，例如写回磁盘等等
  - Read/Write标志
    - 页的读写权限（见后面的“硬件保护方案”）
  - User/Supervisor标志
    - 访问页所需的特权级（见后面的“硬件保护方案”）
  - PCD和PWT标志
    - 控制硬件高速缓存处理页的方式（见后面的“硬件高速缓存”）
  - Page Size标志
    - 只用于页目录项，如果设为1，则页目录项指的是2MB或4MB的页框（见2.4.2）
  - Global标志
    - 只用于页表项
    - 防止常用页从高速缓存中刷新出去（见后面的“转换后院缓冲器TLB”）
    - 只有在cr4寄存器的页全局标志被置位时，才起作用

### 2.4.2 扩展分页

- 页框大小为4MB而非4KB
- 32位地址被分为两个域
  - 高10位的目录
  - 低22位的页内偏移量
- 通过设置cr4处理器寄存器的PSE标志能使扩展分页与常规分页共存？？？

### 2.4.3 硬件保护方案

- 尽管80x86处理器允许一个段使用4种可能的特权级别，但与页机制相关的特权级只有两个，由页表项的User/Supervisor标志来控制
  - 若这个标志为0，只有当CPL小于3（Linux处于内核态）时才能对页寻址
  - 否则，总能对页寻址
- 页的存取权限只有两种，分别为读、写
  - 段有3种存取权限，分别为读、写、执行？？？
  - 如果页表项的Read/Write标志为0，说明对应的页是只读的，否则是可读写的

### 2.4.4 常规分页举例

- ###

### 2.4.5 物理地址扩展（PAE）分页机制

- 处理器所支持的RAM容量受到地址总线上的地址管脚数限制

  - 早期Intel处理器使用32位物理地址
    - 这样的系统可以安装4GB的RAM
    - 实际上，由于用户进程线性地址空间的需要，内核不能直接对1GB以上的RAM进行寻址（2.5）
    - 大型服务器需要大于4GB的DRAM，因此必须扩展32位80x86结构所支持的RAM容量
  - Intel在处理器上把管脚数从32增加到36，使得寻址能力达到64GB
    - 需要引入新的分页机制，把32位线性地址转换为36位物理地址

- Intel引入一种物理地址扩展的机制

  - 另一种机制叫做页大小扩展，Linux没有采用这种机制，因此不作讨论
  - 通过设置cr4控制寄存器中的物理地址扩展（PAE）标志激活PAE
  - 如果要启用大尺寸页，页目录项中的页大小标志PS启用大尺寸页（2MB）

- Intel为了支持PAE，改变了分页机制

  - 页表项的物理地址字段从20位扩展到24位，标志位12个（2.4.1），总数之和为36，因此把页表项大小设为64位

    - 为什么不能设为36位？？？
    - 一个4KB的页表包含512个页表项，而非之前的1024个

  - 引入页目录指针表（PDPT）的页表新级别

    - 4个64位表项

  - cr3控制器包含一个27位的页目录指针表基地址字段

    - PDPT存放在RAM的前4GB，且32字节对齐，因此27位足以表示基地址

  - 把线性地址映射到4KB页时，32位线性地址按下列方式解释

    - cr3
      - 指向一个PDPT
    - 位31~30
      - 指向4个PDPT项中的一个
    - 位29~21
      - 指向512个页目录项中的一个
    - 位20~12
      - 指向512个页表项中的一个
    - 位11~0
      - 4KB页中的偏移量

  - 把线性地址映射到2MB的页时，32位线性地址按下列方式解释

    - cr3
      - 指向一个PDPT
    - 位31~30
      - 指向4个PDPT项中的一个
    - 位29~21
      - 指向512个页目录项中的一个

    - 位20~0
      - 2MB页中的偏移量

- 从上面的分析可以看出，一旦cr3确定，寻找空间就可以达到4GB

  - 如果希望对更多的RAM寻址，就必须更新cr3的值，或改变PDPT的内容

- 线性地址仍为32位，因此同一线性地址会映射到不同的RAM区

  - 当RAM大于4096MB时的最终内核页表，会描述启用PAE时Linux如何初始化页表

- PAE存在的意义

  - 并没有扩大进程的线性地址空间，而只有内核能修改进程的页表，因此用户态运行的进程的地址空间还是不能大于4GB
  - PAE允许内核使用容量为64GB的RAM，从而显著增加了系统中的进程数量

### 2.4.6 64位系统中的分页

- 32位微处理器普遍采用两级分页，但是两级分页不适合用于64位系统
  - PAE分页机制尽管有第三级分页，但也被视为两级分页
  - 如果64位系统仍采用4KB的页大小，那么页表和页目录的项非常多
  - 因此，所有64位处理器的硬件分页系统都使用了额外的分页级别，具体见表2-4
  - Linux成功地提供了一种通用分页模型，适合于绝大多数所支持的硬件分页系统

### 2.4.7 硬件高速缓存

- ###（见caspp）

### 2.4.8 转换后援缓冲器（TLB）

- ###（见csapp）

## 2.5 Linux中的分页

- Linux采用了一种同时适用于32位和64位系统的普通分页模型

- 从2.6.11版本开始，采用了四级分页模型

  - 4级页表分别为页全局目录、页上级目录、页中间目录、页表
  - 每一部分的大小与具体的计算机体系结构有关
  - 对于没有启用物理地址扩展的32位系统，两级页表足够了，Linux使页上级目录位和页中间目录位全0
    - 页上级目录只有一个表项，是页中间目录的基地址；页中间目录只有一个表项，是页表的基地址

  - 启用了物理地址扩展的32位系统使用了三级页表，取消了页上级目录
  - 64位系统使用三级还是四级分页，取决于硬件对线性地址的划分（表2-4）

- 每个进程有自己的页全局目录和页表集（第9章）

  - 如前所述，cr3保存页全局目录（第一级页表）的基地址
  - 进程切换时（第3章），Linux把cr3控制寄存器的内容保存在前一个执行进程的描述符中，然后把下一个要执行的进程的描述符的值装入cr3寄存器
  - cr3应该是保存页表起始地址的，为什么要保存描述符？？？

- 下面季节列举了一些函数和宏，它们检索内核，查找地址和管理表格所需的信息

### 2.5.1 线性地址字段

- 下列宏简化了页表处理
  - PAGE_SHIFT
    - 指定Offset字段的位数
    - 在80x86处理器时，值为12
    - PAGE_SIZE表示页的大小
    - PAGE_MASK位0xffff000，来屏蔽Offset字段的所有位（把这些位清零）
  - PMD_SHIFT
    - ###
  - PUD_SHIFT
    - ###
  - PGDIR_SHIFT
    - ###
  - PTRS_PER_PTE, PTRS_PER_PMD, PTRS_PER_PUD, PTRS_PER_PGD
    - ###

### 2.5.2 页表处理

- ###

### 2.5.3 物理内存布局

- 在初始化阶段，内核必须建立一个物理地址映射，来指定哪些物理地址范围对内核可用，哪些不可用
  - 内核将以下页框记为保留
    - 在不可用的物理地址范围内的页框
    - 含有内核代码和已初始化的数据结构的页框
  - 保留页框中的页绝不能被动态分配或交换到磁盘上
  - 内核可以被安装在小于3MB的RAM中
- Linux内核安装在RAM从物理地址0x00100000开始的地方，而不是在RAM第一个MB开始的地方，因为
  - 页框0由BIOS使用
  - 物理地址从0x000a0000到0x000fffff的范围通常留给BIOS例程，并且映射ISA图存卡上的内部内存
  - 第一个MB内的其它页框可能有特定计算机模型保留
- 启动过程的一些流程
  - 内核询问BIOS并了解物理内存的大小
  - 内核执行machine_specific_memory_setup()函数，建立物理地址映射
- 映射的一个例子见表2-9
  - 如果这张表是可获取的，那就是内核在BIOS列表的基础上构建的；否则，按照保守的缺省设置构建这张表，从0x9f
  - ###
- 内核可能不会看见BIOS报告的所有物理内存
  - 如果未使用PAE支持来编译，即使有更大的物理内存可用，内核也只能寻址4GB大小的RAM
- setup_memory() 函数在machine_specific_memory_setup()执行后被调用
  - 它分析物理内存区域表，并初始化一些变量来描述内核的物理内存布局