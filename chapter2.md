# 第2章 内存寻址

- 本章介绍寻址技术
- 关于内存管理的三章
  - 本章
  - 第8章，讨论内核怎样给自己分配内存
  - 第9张，怎样给进程分配线性地址

## 2.1 内存地址

### 2.1.1 三种不同的地址

- 逻辑地址
  - 每个逻辑地址由一个段和偏移量组成
- 线性地址（虚拟地址）
- 物理地址

### 2.1.2 逻辑地址转换

- MMU通过一种称为分段单元的硬件电路，把一个逻辑地址转换成线性地址；接着，分页单元把线性地址转换成一个物理地址，如图2-1

### 2.1.3 内存仲裁器

- 在多处理器系统中，所有CPU共享同一内存

  - 这意味着RAM芯片可以由独立的CPU并发访问

  - 但是RAM芯片上的读写必须串行执行

- 内存仲裁器插在总线和每个RAM芯片上

  - 如果某个RAM芯片空闲，就准许一个CPU访问；如果该芯片正在为另一个处理器提出的请求服务，就延迟这个CPU的访问

- 内存仲裁器在单处理器和多处理器的使用

  - 单处理器上也使用内存仲裁器，因为DMA控制器和CPU并发操作（第13章“直接内存访问（DMA）”）
  - 多处理器系统的仲裁器有多个输入端口，结构更加复杂

- 从编程观点看，仲裁器由硬件电路管理，因此是隐藏的

## 2.2 硬件中的分段

- Intel微处理器以两种不同的方式执行地址转换，这两种方式分别被称为实模式和保护模式
  - 从下一节开始描述保护模式下的地址转换
  - 实模式存在的原因是要维持处理器和早期模型兼容，并让操作系统自举？？？

### 2.2.1 段选择符和段寄存器

- 逻辑地址由两部分组成

  - 段标识符（段选择符）
    - 16位
    - 结构如图2-2
  - 指定段内相对地址的偏移量
    - 32位

- 段寄存器

  - 唯一的目的就是存放段选择符

  - 尽管只有6个，但程序可以把同一个段寄存器用于不同目的，方法是先将其值保存在内存中，用完后再恢复
  - 6个寄存器中，3个有专门的用途
    - cs：代码段寄存器，指向包含程序指令的段
      - 还有一个两位字段，泳衣指明CPU的当前特权级
      - Linux只用0级和3级，分别表示内核态和用户态
    - ss：栈段寄存器，指向包含当前程序栈的段
    - ds：数据段寄存器，指向包含静态数据或全局数据段
    - 其它3个段寄存器做一般用途，可以指向任何数据段

- 逻辑地址如何转换成线性地址见2.2.4

### 2.2.2 段描述符

- 每个段由一个8字节的段描述符表示，描述了段的特征
- 段描述符放在全局描述符表（GDT）或局部描述符表（LDT）
  - 通常只定义一个GDT
  - 每个进程除了存放在GDT中的段之外，如果还需要创建附加的段，就可以有自己的LDT
  - GDT在主存中的地址和大小存放在gdtr控制寄存器中
  - 当前正被使用的LDT地址和大小放在ldtr控制寄存器中
- 图2-3展示了段描述符的格式，表2-1解释了图2-3中各个字段的含义
  - ###
- 几种不同类型的段，以及和它们对应的段描述符
  - 代码段描述符
  - 数据段描述符
  - 任务状态段描述符（TSSD）
  - 局部描述符表描述符

### 2.2.3 快速访问段描述符

- 回忆之前的内容
  - 逻辑地址由16位段选择符和32位偏移量组成
  - 段寄存器仅仅存放段选择符

- 为了加速逻辑地址到线性地址的转换，80x86处理器提供一种附加的非编程的寄存器（不能被程序员设置），供6个可编程的段寄存器使用
  - 每个非编程的寄存器含有8个字节的段描述符，由相应的段寄存器中的段选择符指定
- 每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非编程CPU寄存器
  - 目的是，针对那个段的逻辑地址转换就可以不访问主存中的GDT或LDT，只需要直接引用存放段描述符的CPU寄存器
- 表2-2描述了段选择符包含的3个字段

### 2.2.4 分段单元

- 图2-5显示了一个逻辑地址是怎样转换成相应的线性地址的，分段单元执行如下操作
  - 先检查段选择符的TI字段，以决定段描述符保存在GDT还是激活的LDT
    - 对于这两种情况，分段单元从gdtr寄存器或ldtr寄存器中得到GDT或LDT的线性基地址
  - 把段选择符的index字段乘以8（一个段描述符的大小），这个结果与上一步获得的线性基地址相加，得到段描述符的地址
  - 把逻辑地址的偏移量和段描述符的Base字段的值相加，得到线性地址

- 因为有了与段寄存器相关的不可编程寄存器，只有当段寄存器内容被改变时才需要执行前两个操作

## 2.3 Linux中的分段

